<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P2Pãƒãƒ£ãƒƒãƒˆã‚¢ãƒ—ãƒªï¼ˆæ”¹å–„ç‰ˆï¼‰</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.20.15/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .drag-over {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      transform: scale(1.02);
      transition: all 0.3s ease;
    }
    
    .message-animation {
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .typing-indicator {
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    .file-preview {
      max-width: 200px;
      max-height: 200px;
      object-fit: contain;
      border-radius: 8px;
    }
    
    .connection-status {
      animation: fadeIn 0.5s ease-in;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .gradient-bg {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    
    .glass-effect {
      backdrop-filter: blur(10px);
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
  </style>
</head>
<body class="bg-gray-50 min-h-screen">
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function App() {
      const [peerId, setPeerId] = useState('');
      const [remotePeerId, setRemotePeerId] = useState('');
      const [message, setMessage] = useState('');
      const [messages, setMessages] = useState([]);
      const [connectionStatus, setConnectionStatus] = useState('æœªæ¥ç¶š');
      const [isDragging, setIsDragging] = useState(false);
      const [isTyping, setIsTyping] = useState(false);
      const [fileTransferProgress, setFileTransferProgress] = useState({});
      const [notification, setNotification] = useState('');
      const [userName, setUserName] = useState('');
      const [remoteName, setRemoteName] = useState('');
      const [isNameSet, setIsNameSet] = useState(false);

      const peerInstance = useRef(null);
      const connRef = useRef(null);
      const cryptoKey = useRef(null);
      const messagesEndRef = useRef(null);
      const dropZoneRef = useRef(null);
      const typingTimeoutRef = useRef(null);

      // é€šçŸ¥è¡¨ç¤º
      const showNotification = (msg) => {
        setNotification(msg);
        setTimeout(() => setNotification(''), 3000);
      };

      // æš—å·åŒ–ã‚­ãƒ¼ã®ç”Ÿæˆ
      const generateKey = async () => {
        try {
          return await window.crypto.subtle.generateKey(
            {
              name: 'AES-GCM',
              length: 256,
            },
            true,
            ['encrypt', 'decrypt']
          );
        } catch (e) {
          showNotification('æš—å·åŒ–ã‚­ãƒ¼ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
          return null;
        }
      };

      // ArrayBufferã‚’Base64ã«å¤‰æ›
      const arrayBufferToBase64 = (buffer) => {
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.byteLength; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      };

      // Base64ã‚’ArrayBufferã«å¤‰æ›
      const base64ToArrayBuffer = (base64) => {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes.buffer;
      };

      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æš—å·åŒ–
      const encryptMessage = async (text) => {
        if (!cryptoKey.current) {
          showNotification('æš—å·åŒ–ã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
          return null;
        }
        const encoder = new TextEncoder();
        const data = encoder.encode(text);
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encrypted = await window.crypto.subtle.encrypt(
          {
            name: 'AES-GCM',
            iv: iv,
          },
          cryptoKey.current,
          data
        );
        return { 
          iv: arrayBufferToBase64(iv), 
          encrypted: arrayBufferToBase64(encrypted) 
        };
      };

      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å¾©å·åŒ–
      const decryptMessage = async ({ iv, encrypted }) => {
        try {
          const decrypted = await window.crypto.subtle.decrypt(
            {
              name: 'AES-GCM',
              iv: base64ToArrayBuffer(iv),
            },
            cryptoKey.current,
            base64ToArrayBuffer(encrypted)
          );
          const decoder = new TextDecoder();
          return decoder.decode(decrypted);
        } catch (e) {
          return 'å¾©å·åŒ–ã‚¨ãƒ©ãƒ¼';
        }
      };

      // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿ã®æš—å·åŒ–
      const encryptFile = async (file) => {
        if (!cryptoKey.current) {
          showNotification('æš—å·åŒ–ã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
          return null;
        }
        const arrayBuffer = await file.arrayBuffer();
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encrypted = await window.crypto.subtle.encrypt(
          {
            name: 'AES-GCM',
            iv: iv,
          },
          cryptoKey.current,
          arrayBuffer
        );
        return { 
          iv: arrayBufferToBase64(iv), 
          encrypted: arrayBufferToBase64(encrypted), 
          name: file.name, 
          type: file.type, 
          size: file.size 
        };
      };

      // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿ã®å¾©å·åŒ–
      const decryptFile = async ({ iv, encrypted, name, type, size }) => {
        try {
          const decrypted = await window.crypto.subtle.decrypt(
            {
              name: 'AES-GCM',
              iv: base64ToArrayBuffer(iv),
            },
            cryptoKey.current,
            base64ToArrayBuffer(encrypted)
          );
          // Ensure the decrypted data is correctly converted to a File
          const blob = new Blob([decrypted], { type: type || 'application/octet-stream' });
          return new File([blob], name, { type: type || 'application/octet-stream' });
        } catch (e) {
          showNotification(`ãƒ•ã‚¡ã‚¤ãƒ«å¾©å·åŒ–ã‚¨ãƒ©ãƒ¼: ${name}`);
          console.error('Decryption error:', e);
          return null;
        }
      };

      // ã‚­ãƒ¼ã‚’ ArrayBuffer ã«å¤‰æ›ã—ã¦é€ä¿¡
      const exportKey = async (key) => {
        const exported = await window.crypto.subtle.exportKey('raw', key);
        return arrayBufferToBase64(exported);
      };

      // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
      const formatTimestamp = () => {
        return new Date().toLocaleString('ja-JP', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });
      };

      // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
      const formatFileSize = (bytes) => {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      };

      // ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‹ã©ã†ã‹åˆ¤å®š
      const isImageFile = (type) => {
        return type.startsWith('image/');
      };

      // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
      const handleTyping = () => {
        if (connRef.current) {
          connRef.current.send({ type: 'typing', user: userName });
          
          if (typingTimeoutRef.current) {
            clearTimeout(typingTimeoutRef.current);
          }
          
          typingTimeoutRef.current = setTimeout(() => {
            if (connRef.current) {
              connRef.current.send({ type: 'stop-typing' });
            }
          }, 2000);
        }
      };

      // ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†å¸°çš„ã«å–å¾—
      const readDirectory = async (entry, path = '') => {
        const files = [];
        if (entry.isFile) {
          const file = await new Promise((resolve) => {
            entry.file(resolve, () => resolve(null));
          });
          if (file) {
            file.relativePath = path ? `${path}/${entry.name}` : entry.name;
            files.push(file);
          }
        } else if (entry.isDirectory) {
          const dirReader = entry.createReader();
          const entries = await new Promise((resolve) => {
            dirReader.readEntries(resolve, () => resolve([]));
          });
          for (const subEntry of entries) {
            const subFiles = await readDirectory(subEntry, path ? `${path}/${entry.name}` : entry.name);
            files.push(...subFiles);
          }
        }
        return files;
      };

      // ãƒ‰ãƒ©ãƒƒã‚°ã‚¢ãƒ³ãƒ‰ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†
      const handleDragOver = (e) => {
        e.preventDefault();
        if (!isDragging) {
          setIsDragging(true);
        }
      };

      const handleDragLeave = (e) => {
        e.preventDefault();
        if (!dropZoneRef.current?.contains(e.relatedTarget)) {
          setIsDragging(false);
        }
      };

      const handleDrop = async (e) => {
        e.preventDefault();
        setIsDragging(false);
        
        const items = Array.from(e.dataTransfer.items);
        const files = [];
        
        // Process both files and folders
        for (const item of items) {
          const entry = item.webkitGetAsEntry();
          if (entry) {
            if (entry.isFile) {
              const file = await new Promise((resolve) => {
                entry.file(resolve, () => resolve(null));
              });
              if (file) files.push(file);
            } else if (entry.isDirectory) {
              const folderFiles = await readDirectory(entry);
              files.push(...folderFiles);
            }
          }
        }
        
        if (files.length > 0 && connRef.current && cryptoKey.current) {
          await processFiles(files);
        } else {
          showNotification('ãƒ•ã‚¡ã‚¤ãƒ«é€ä¿¡ã«ã¯æ¥ç¶šã¨æš—å·åŒ–ã‚­ãƒ¼ãŒå¿…è¦ã§ã™');
        }
      };

      // ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã®å…±é€šåŒ–
      const processFiles = async (files) => {
        for (const file of files) {
          const fileId = Date.now() + Math.random();
          setFileTransferProgress(prev => ({ ...prev, [fileId]: 0 }));
          
          try {
            const encryptedFile = await encryptFile(file);
            if (!encryptedFile) {
              throw new Error('ãƒ•ã‚¡ã‚¤ãƒ«ã®æš—å·åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
            connRef.current.send({ type: 'file', ...encryptedFile });
            
            // æ¨¡æ“¬çš„ãªé€²æ—ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            let progress = 0;
            const interval = setInterval(() => {
              progress += 10;
              setFileTransferProgress(prev => ({ ...prev, [fileId]: Math.min(progress, 100) }));
              if (progress >= 100) {
                clearInterval(interval);
                setTimeout(() => {
                  setFileTransferProgress(prev => {
                    const newProgress = { ...prev };
                    delete newProgress[fileId];
                    return newProgress;
                  });
                }, 1000);
              }
            }, 200);
            
            const url = URL.createObjectURL(file);
            const newMessage = {
              sender: 'local',
              text: `ãƒ•ã‚¡ã‚¤ãƒ«é€ä¿¡: ${file.name}`,
              fileUrl: url,
              fileName: file.name,
              fileSize: file.size,
              fileType: file.type,
              timestamp: formatTimestamp()
            };
            
            setMessages(prev => [...prev, newMessage]);
            showNotification(`${file.name} ã‚’é€ä¿¡ã—ã¾ã—ãŸ`);
          } catch (error) {
            showNotification(`ãƒ•ã‚¡ã‚¤ãƒ«é€ä¿¡ã‚¨ãƒ©ãƒ¼: ${file.name}`);
            setFileTransferProgress(prev => {
              const newProgress = { ...prev };
              delete newProgress[fileId];
              return newProgress;
            });
          }
        }
      };

      // ãƒ‡ãƒ¼ã‚¿å—ä¿¡å‡¦ç†ã®å…±é€šåŒ–
      const handleData = async (data) => {
        if (data.type === 'key') {
          try {
            cryptoKey.current = await window.crypto.subtle.importKey(
              'raw',
              base64ToArrayBuffer(data.key),
              { name: 'AES-GCM' },
              false,
              ['encrypt', 'decrypt']
            );
            setMessages(prev => [...prev, { sender: 'system', text: 'æš—å·åŒ–ã‚­ãƒ¼ã‚’å—ä¿¡ã—ã¾ã—ãŸ', timestamp: formatTimestamp() }]);
          } catch (e) {
            showNotification('æš—å·åŒ–ã‚­ãƒ¼ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ');
          }
        } else if (data.type === 'message') {
          const decryptedText = await decryptMessage(data);
          setMessages(prev => [...prev, { sender: 'remote', text: decryptedText, timestamp: formatTimestamp() }]);
          showNotification('æ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå±Šãã¾ã—ãŸ');
        } else if (data.type === 'file') {
          const decryptedFile = await decryptFile(data);
          if (decryptedFile) {
            const url = URL.createObjectURL(decryptedFile);
            setMessages(prev => [...prev, {
              sender: 'remote',
              text: `ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å—ä¿¡: ${data.name}`,
              fileUrl: url,
              fileName: data.name,
              fileSize: data.size,
              fileType: data.type,
              timestamp: formatTimestamp()
            }]);
            showNotification(`ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å—ä¿¡: ${data.name}`);
          } else {
            setMessages(prev => [...prev, { sender: 'system', text: `ãƒ•ã‚¡ã‚¤ãƒ«å¾©å·åŒ–ã‚¨ãƒ©ãƒ¼: ${data.name}`, timestamp: formatTimestamp() }]);
          }
        } else if (data.type === 'typing') {
          setRemoteName(data.user || 'ç›¸æ‰‹');
          setIsTyping(true);
        } else if (data.type === 'stop-typing') {
          setIsTyping(false);
        } else if (data.type === 'user-info') {
          setRemoteName(data.name);
        }
      };

      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ›´æ–°æ™‚ã«æœ€ä¸‹éƒ¨ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
      useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      useEffect(() => {
        const peer = new Peer({
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
            ]
          }
        });
        peerInstance.current = peer;

        peer.on('open', async (id) => {
          setPeerId(id);
          setConnectionStatus('Peer ID ç”Ÿæˆæ¸ˆã¿');
          cryptoKey.current = await generateKey();
        });

        peer.on('connection', (conn) => {
          connRef.current = conn;
          setConnectionStatus('æ¥ç¶šæ¸ˆã¿');
          showNotification('æ–°ã—ã„æ¥ç¶šãŒç¢ºç«‹ã•ã‚Œã¾ã—ãŸ');
          
          conn.on('data', handleData);
          
          conn.on('close', () => {
            setConnectionStatus('åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ');
            setMessages(prev => [...prev, { sender: 'system', text: 'æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸ', timestamp: formatTimestamp() }]);
            connRef.current = null;
            showNotification('æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸ');
          });
        });

        peer.on('error', (err) => {
          setMessages(prev => [...prev, { sender: 'system', text: `ã‚¨ãƒ©ãƒ¼: ${err.message}`, timestamp: formatTimestamp() }]);
          setConnectionStatus(`ã‚¨ãƒ©ãƒ¼: ${err.type}`);
          showNotification(`ã‚¨ãƒ©ãƒ¼: ${err.message}`);
        });

        return () => peer.destroy();
      }, []);

      const connectToPeer = async () => {
        if (!remotePeerId) {
          showNotification('Peer IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
          return;
        }
        setConnectionStatus('æ¥ç¶šä¸­...');
        const conn = peerInstance.current.connect(remotePeerId);
        connRef.current = conn;
        
        conn.on('open', async () => {
          setConnectionStatus('æ¥ç¶šæ¸ˆã¿');
          const keyData = await exportKey(cryptoKey.current);
          conn.send({ type: 'key', key: keyData });
          
          if (userName) {
            conn.send({ type: 'user-info', name: userName });
          }
          
          setMessages(prev => [...prev, { sender: 'system', text: 'æš—å·åŒ–ã‚­ãƒ¼ã‚’é€ä¿¡ã—ã¾ã—ãŸ', timestamp: formatTimestamp() }]);
          showNotification('æ¥ç¶šãŒç¢ºç«‹ã•ã‚Œã¾ã—ãŸ');
          
          conn.on('data', handleData);
          
          conn.on('close', () => {
            setConnectionStatus('åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ');
            setMessages(prev => [...prev, { sender: 'system', text: 'æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸ', timestamp: formatTimestamp() }]);
            connRef.current = null;
            showNotification('æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸ');
          });
        });
        
        conn.on('error', (err) => {
          setMessages(prev => [...prev, { sender: 'system', text: `æ¥ç¶šã‚¨ãƒ©ãƒ¼: ${err.message}`, timestamp: formatTimestamp() }]);
          setConnectionStatus(`ã‚¨ãƒ©ãƒ¼: ${err.type}`);
          showNotification(`æ¥ç¶šã‚¨ãƒ©ãƒ¼: ${err.message}`);
        });
      };

      const sendMessage = async () => {
        if (message && connRef.current && cryptoKey.current) {
          const encryptedMessage = await encryptMessage(message);
          if (!encryptedMessage) {
            return;
          }
          connRef.current.send({ type: 'message', ...encryptedMessage });
          setMessages(prev => [...prev, { sender: 'local', text: message, timestamp: formatTimestamp() }]);
          setMessage('');
          
          if (typingTimeoutRef.current) {
            clearTimeout(typingTimeoutRef.current);
            connRef.current.send({ type: 'stop-typing' });
          }
        } else {
          showNotification('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã™ã‚‹ã«ã¯æ¥ç¶šã¨æš—å·åŒ–ã‚­ãƒ¼ãŒå¿…è¦ã§ã™');
        }
      };

      const handleKeyPress = (e) => {
        if (e.key === 'Enter') {
          sendMessage();
        }
      };

      const handleMessageChange = (e) => {
        setMessage(e.target.value);
        handleTyping();
      };

      const copyPeerId = () => {
        navigator.clipboard.writeText(peerId);
        showNotification('Peer IDã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
      };

      const clearMessages = () => {
        setMessages([]);
        showNotification('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
      };

      const disconnect = () => {
        if (connRef.current) {
          connRef.current.close();
          connRef.current = null;
          setConnectionStatus('åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ');
          showNotification('æ¥ç¶šã‚’åˆ‡æ–­ã—ã¾ã—ãŸ');
        }
      };

      const handleNameSubmit = () => {
        if (userName.trim()) {
          setIsNameSet(true);
        } else {
          showNotification('åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        }
      };

      // åå‰å…¥åŠ›ç”»é¢
      if (!isNameSet) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center">
            <div className="bg-white rounded-lg shadow-xl p-6 max-w-md w-full">
              <h1 className="text-2xl font-bold mb-4 text-center gradient-bg bg-clip-text text-transparent">
                åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„
              </h1>
              <input
                type="text"
                value={userName}
                onChange={(e) => setUserName(e.target.value)}
                placeholder="ã‚ãªãŸã®åå‰"
                className="w-full p-3 border rounded-lg border-gray-300 mb-4"
                onKeyPress={(e) => e.key === 'Enter' && handleNameSubmit()}
              />
              <button
                onClick={handleNameSubmit}
                className="w-full bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600 transition-colors"
              >
                é–‹å§‹
              </button>
            </div>
          </div>
        );
      }

      return (
        <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
          <div className="max-w-4xl mx-auto p-4 sm:p-6">
            {/* é€šçŸ¥ */}
            {notification && (
              <div className="fixed top-4 right-4 z-50 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg animate-pulse">
                {notification}
              </div>
            )}

            {/* ãƒ˜ãƒƒãƒ€ãƒ¼ï¼ˆæ¥ç¶šå‰ï¼‰ */}
            {connectionStatus !== 'æ¥ç¶šæ¸ˆã¿' && (
              <div className="bg-white rounded-lg shadow-xl p-6 mb-6">
                <div className="flex justify-between items-center mb-4">
                  <h1 className="text-3xl font-bold gradient-bg bg-clip-text text-transparent">
                    P2Pæš—å·åŒ–ãƒãƒ£ãƒƒãƒˆ
                  </h1>
                </div>
                
                <div className="grid grid-cols-1 gap-4">
                  <div>
                    <label className="block text-sm font-medium mb-1">ã‚ãªãŸã®Peer ID</label>
                    <div className="flex">
                      <input
                        type="text"
                        value={peerId}
                        readOnly
                        className="flex-1 p-2 border rounded-l-lg border-gray-300 font-mono text-sm"
                      />
                      <button
                        onClick={copyPeerId}
                        disabled={!peerId}
                        className="bg-indigo-500 text-white px-4 py-2 rounded-r-lg hover:bg-indigo-600 disabled:opacity-50 transition-colors"
                      >
                        ã‚³ãƒ”ãƒ¼
                      </button>
                    </div>
                  </div>
                </div>
                
                <div className={`mt-4 p-3 rounded-lg ${connectionStatus === 'æ¥ç¶šæ¸ˆã¿' ? 'bg-green-100 text-green-800' : connectionStatus.includes('ã‚¨ãƒ©ãƒ¼') ? 'bg-red-100 text-red-800' : 'bg-yellow-100 text-yellow-800'} connection-status`}>
                  <div className="flex items-center">
                    <div className={`w-3 h-3 rounded-full mr-2 ${connectionStatus === 'æ¥ç¶šæ¸ˆã¿' ? 'bg-green-500' : connectionStatus.includes('ã‚¨ãƒ©ãƒ¼') ? 'bg-red-500' : 'bg-yellow-500'}`}></div>
                    æ¥ç¶šçŠ¶æ…‹: {connectionStatus}
                  </div>
                </div>
              </div>
            )}

            {/* æ¥ç¶šã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆæ¥ç¶šå‰ï¼‰ */}
            {connectionStatus !== 'æ¥ç¶šæ¸ˆã¿' && (
              <div className="bg-white rounded-lg shadow-xl p-6 mb-6">
                <h2 className="text-xl font-semibold mb-4">æ¥ç¶š</h2>
                <div className="flex flex-col sm:flex-row gap-4">
                  <input
                    type="text"
                    value={remotePeerId}
                    onChange={(e) => setRemotePeerId(e.target.value)}
                    placeholder="æ¥ç¶šã™ã‚‹Peer IDã‚’å…¥åŠ›"
                    className="flex-1 p-3 border rounded-lg border-gray-300"
                  />
                  <button
                    onClick={connectToPeer}
                    disabled={!remotePeerId || connectionStatus === 'æ¥ç¶šä¸­...'}
                    className="bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600 disabled:opacity-50 transition-colors"
                  >
                    {connectionStatus === 'æ¥ç¶šä¸­...' ? 'æ¥ç¶šä¸­...' : 'æ¥ç¶š'}
                  </button>
                </div>
              </div>
            )}

            {/* ãƒãƒ£ãƒƒãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆæ¥ç¶šå¾Œï¼‰ */}
            {connectionStatus === 'æ¥ç¶šæ¸ˆã¿' && (
              <div className="bg-white rounded-lg shadow-xl p-6">
                <div className="flex justify-between items-center mb-4">
                  <h2 className="text-xl font-semibold">
                    ãƒãƒ£ãƒƒãƒˆ {remoteName && `with ${remoteName}`}
                  </h2>
                  <div className="flex gap-2">
                    <button
                      onClick={clearMessages}
                      className="text-gray-500 hover:text-gray-700 transition-colors"
                    >
                      ğŸ—‘ï¸ ã‚¯ãƒªã‚¢
                    </button>
                    <button
                      onClick={disconnect}
                      className="text-red-500 hover:text-red-700 transition-colors"
                    >
                      ğŸ”Œ åˆ‡æ–­
                    </button>
                  </div>
                </div>
                
                {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¨ãƒªã‚¢ */}
                <div 
                  ref={dropZoneRef}
                  className={`h-[60vh] overflow-y-auto border-2 border-dashed p-4 mb-4 rounded-lg transition-all duration-300 ${
                    isDragging 
                      ? 'border-blue-500 bg-blue-50 drag-over' 
                      : 'border-gray-300 bg-gray-50'
                  }`}
                  onDragOver={handleDragOver}
                  onDragLeave={handleDragLeave}
                  onDrop={handleDrop}
                >
                  {isDragging && (
                    <div className="absolute inset-0 flex items-center justify-center bg-blue-100 bg-opacity-90 rounded-lg z-10">
                      <div className="text-center">
                        <div className="text-4xl mb-2">ğŸ“</div>
                        <div className="text-blue-600 font-semibold">ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ•ã‚©ãƒ«ãƒ€ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦ãã ã•ã„</div>
                      </div>
                    </div>
                  )}
                  
                  {messages.map((msg, index) => (
                    <div
                      key={index}
                      className={`mb-3 message-animation ${
                        msg.sender === 'local' ? 'text-right' : 
                        msg.sender === 'system' ? 'text-center' : 'text-left'
                      }`}
                    >
                      <div
                        className={`inline-block p-3 rounded-lg max-w-xs sm:max-w-md ${
                          msg.sender === 'local' 
                            ? 'bg-blue-500 text-white' 
                            : msg.sender === 'system' 
                              ? 'bg-gray-200 text-gray-800' 
                              : 'bg-gray-100 text-gray-800'
                        } shadow-md`}
                      >
                        <div className="text-xs opacity-70 mb-1">{msg.timestamp}</div>
                        <div className="break-words">{msg.text}</div>
                        {msg.fileUrl && (
                          <div className="mt-2">
                            {isImageFile(msg.fileType) && (
                              <img 
                                src={msg.fileUrl} 
                                alt={msg.fileName}
                                className="file-preview mb-2"
                              />
                            )}
                            <a
                              href={msg.fileUrl}
                              download={msg.fileName}
                              className="inline-flex items-center bg-white bg-opacity-20 px-3 py-1 rounded text-sm hover:bg-opacity-30 transition-colors"
                            >
                              ğŸ“ {msg.fileName}
                              {msg.fileSize && <span className="ml-2 text-xs">({formatFileSize(msg.fileSize)})</span>}
                            </a>
                          </div>
                        )}
                      </div>
                    </div>
                  ))}
                  
                  {isTyping && (
                    <div className="text-left mb-3">
                      <div className="inline-block p-3 bg-gray-100 rounded-lg typing-indicator">
                        <div className="text-xs text-gray-500 mb-1">{remoteName}</div>
                        <div className="text-gray-600">å…¥åŠ›ã—ã¦ã„ã¾ã™...</div>
                      </div>
                    </div>
                  )}
                  
                  <div ref={messagesEndRef} />
                </div>

                {/* å…¥åŠ›ã‚¨ãƒªã‚¢ */}
                <div className="space-y-4">
                  <div className="flex gap-2">
                    <input
                      type="text"
                      value={message}
                      onChange={handleMessageChange}
                      onKeyPress={handleKeyPress}
                      placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›..."
                      className="flex-1 p-3 border rounded-lg border-gray-300"
                    />
                    <button
                      onClick={sendMessage}
                      disabled={!message.trim()}
                      className="bg-green-500 text-white px-6 py-3 rounded-lg hover:bg-green-600 disabled:opacity-50 transition-colors"
                    >
                      é€ä¿¡
                    </button>
                  </div>
                  
                  <div className="text-sm text-gray-500">
                    ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ•ã‚©ãƒ«ãƒ€ã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦ãã ã•ã„
                  </div>
                  
                  {/* ãƒ•ã‚¡ã‚¤ãƒ«è»¢é€é€²æ— */}
                  {Object.keys(fileTransferProgress).length > 0 && (
                    <div className="space-y-2">
                      {Object.entries(fileTransferProgress).map(([id, progress]) => (
                        <div key={id} className="bg-gray-100 rounded-lg p-2">
                          <div className="flex justify-between text-sm mb-1">
                            <span>ãƒ•ã‚¡ã‚¤ãƒ«è»¢é€ä¸­...</span>
                            <span>{progress}%</span>
                          </div>
                          <div className="w-full bg-gray-200 rounded-full h-2">
                            <div 
                              className="bg-blue-500 h-2 rounded-full transition-all duration-300"
                              style={{ width: `${progress}%` }}
                            ></div>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
